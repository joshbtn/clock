<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clock Sync Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0a0a0a; color: #fbbf24; }
        .card { background-color: #171717; border: 1px solid #262626; }
        .toggle-input {
            appearance: none;
            width: 3rem;
            height: 1.5rem;
            background-color: #3f3f46;
            border-radius: 9999px;
            cursor: pointer;
            outline: none;
            transition: background-color 0.3s;
            position: relative;
        }
        .toggle-input:checked {
            background-color: #f59e0b;
        }
        .toggle-input::after {
            content: '';
            position: absolute;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            background-color: white;
            top: 0.125rem;
            left: 0.125rem;
            transition: left 0.3s;
        }
        .toggle-input:checked::after {
            left: 1.625rem;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div class="w-full max-w-2xl space-y-4">
        <!-- Main Card -->
        <div class="card p-6 rounded-2xl shadow-2xl">
            <h1 class="text-2xl font-bold mb-2 text-center">Clock Dashboard</h1>
            <p class="text-neutral-500 text-sm mb-6 text-center">Ultra-Compact Bedroom Sync</p>
            
            <div id="status" class="mb-6 p-3 rounded-lg bg-neutral-900 border border-neutral-800 text-center text-sm">
                Status: Disconnected
            </div>

            <button id="connect" class="w-full py-4 bg-amber-500 hover:bg-amber-600 text-black font-bold rounded-xl transition-all mb-2">
                Connect to Clock
            </button>

            <button id="disconnect" class="hidden w-full py-2 bg-red-700 hover:bg-red-800 text-white rounded-lg transition-all text-sm mb-4">
                Disconnect
            </button>

            <div class="space-y-4 opacity-50 pointer-events-none" id="controls">
                <!-- Format Toggle -->
                <div class="p-4 border border-neutral-800 rounded-lg">
                    <label class="block text-sm mb-3 text-neutral-400">Display Format</label>
                    <div class="flex items-center justify-between">
                        <span class="text-sm">24-Hour</span>
                        <input type="checkbox" id="format12h" class="toggle-input">
                        <span class="text-sm">12-Hour</span>
                    </div>
                    <div class="text-center text-xs text-neutral-500 mt-2">Current: <span id="formatDisplay">24-Hour</span></div>
                </div>

                <!-- Timezone Selector -->
                <div class="p-4 border border-neutral-800 rounded-lg">
                    <label class="block text-sm mb-2 text-neutral-400">Timezone (for DST)</label>
                    <select id="timezone" class="w-full bg-neutral-800 text-amber-500 border border-neutral-700 rounded-lg p-2 text-sm">
                        <option value="0">UTC (No DST)</option>
                        <option value="-5">Eastern (EST/EDT)</option>
                        <option value="-6">Central (CST/CDT)</option>
                        <option value="-7">Mountain (MST/MDT)</option>
                        <option value="-8">Pacific (PST/PDT)</option>
                    </select>
                    <div class="text-center text-xs text-neutral-500 mt-2">Offset: <span id="tzDisplay">UTC</span></div>
                </div>
                
                <!-- Brightness Control -->
                <div class="p-4 border border-neutral-800 rounded-lg">
                    <label class="block text-sm mb-2 text-neutral-400">Display Brightness</label>
                    <div class="flex items-center gap-3">
                        <span class="text-xs text-neutral-500">Low</span>
                        <input type="range" id="brightness" min="0" max="7" value="5" class="flex-1 h-2 bg-neutral-800 rounded-lg appearance-none cursor-pointer accent-amber-500">
                        <span class="text-xs text-neutral-500">High</span>
                    </div>
                    <div class="text-center text-xs text-neutral-400 mt-2">Level: <span id="brightnessValue">5</span></div>
                </div>
                
                <!-- Status Display -->
                <div class="grid grid-cols-2 gap-3 text-center text-xs text-neutral-400">
                    <div class="p-2 border border-neutral-800 rounded-lg">
                        DST: <span id="dstDisplay">--</span>
                    </div>
                    <div class="p-2 border border-neutral-800 rounded-lg">
                        Auto-Sync: <span id="autoSyncStatus">Off</span>
                    </div>
                </div>

                <div class="p-2 border border-neutral-800 rounded-lg text-xs text-neutral-400">
                    Serial: <span id="serialLog" class="text-neutral-300">--</span>
                </div>

                <!-- Sync Settings Button -->
                <button id="syncSettings" class="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg border border-blue-500 transition-all font-semibold">
                    Sync Settings to Device
                </button>
            </div>
        </div>

        <!-- Info Card -->
        <div class="card p-4 rounded-lg text-xs text-neutral-500 space-y-2">
            <p><strong>Initial Setup:</strong> Click "Initial Setup" once to sync date, time, and load DST rules.</p>
            <p><strong>Format:</strong> Toggle 12/24-hour display. Your preference is saved on the device.</p>
            <p><strong>Auto-Increment:</strong> After setup, the device advances the date automatically each day.</p>
            <p><strong>DST:</strong> The device applies US DST rules autonomously—no daily syncs needed.</p>
        </div>
    </div>

    <script>
        let port;
        let writer;
        let reader;
        let isConnected = false;
        let dstTableLoaded = false;
        let dstRules = null;
        let serialRxBuffer = '';
        let isUpdatingFromDevice = false;

        const connectBtn = document.getElementById('connect');
        const disconnectBtn = document.getElementById('disconnect');
        const statusDiv = document.getElementById('status');
        const controls = document.getElementById('controls');
        const format12hToggle = document.getElementById('format12h');
        const formatDisplay = document.getElementById('formatDisplay');
        const timezoneSelect = document.getElementById('timezone');
        const tzDisplay = document.getElementById('tzDisplay');
        const brightnessSlider = document.getElementById('brightness');
        const brightnessValue = document.getElementById('brightnessValue');
        const dstDisplay = document.getElementById('dstDisplay');
        const autoSyncStatus = document.getElementById('autoSyncStatus');
        const serialLog = document.getElementById('serialLog');
        const syncSettingsBtn = document.getElementById('syncSettings');

        async function cleanupSerialConnection() {
            try {
                if (reader) {
                    try { await reader.cancel(); } catch (_) {}
                    try { reader.releaseLock(); } catch (_) {}
                    reader = null;
                }

                if (writer) {
                    try { writer.releaseLock(); } catch (_) {}
                    writer = null;
                }

                if (port) {
                    try { await port.close(); } catch (_) {}
                    port = null;
                }
            } catch (_) {}

            isConnected = false;
            connectBtn.disabled = false;
            connectBtn.innerText = 'Connect to Clock';
            disconnectBtn.classList.add('hidden');
            controls.classList.add('opacity-50', 'pointer-events-none');
        }

        // ============= DST Table Generator =============
        function generateDSTRules() {
            // US DST Rules 2026-2035
            // 2nd Sunday in March, 1st Sunday in November
            const rules = [
                {year: 2026, spring_day: 8, fall_day: 1},   // Mar 8, Nov 1
                {year: 2027, spring_day: 14, fall_day: 7},  // Mar 14, Nov 7
                {year: 2028, spring_day: 12, fall_day: 5},  // Mar 12, Nov 5
                {year: 2029, spring_day: 11, fall_day: 4},  // Mar 11, Nov 4
                {year: 2030, spring_day: 10, fall_day: 3},  // Mar 10, Nov 3
                {year: 2031, spring_day: 9, fall_day: 2},   // Mar 9, Nov 2
                {year: 2032, spring_day: 14, fall_day: 7},  // Mar 14, Nov 7
                {year: 2033, spring_day: 13, fall_day: 6},  // Mar 13, Nov 6
                {year: 2034, spring_day: 12, fall_day: 5},  // Mar 12, Nov 5
                {year: 2035, spring_day: 11, fall_day: 4}   // Mar 11, Nov 4
            ];
            return rules;
        }

        function createDSTBinaryBlob() {
            const rules = generateDSTRules();
            const blob = new Uint8Array(40);  // 10 years × 4 bytes
            
            for (let i = 0; i < 10; i++) {
                const rule = rules[i];
                blob[i * 4 + 0] = i;                      // year_offset
                blob[i * 4 + 1] = rule.spring_day;        // spring_day
                blob[i * 4 + 2] = rule.fall_day;          // fall_day
                blob[i * 4 + 3] = 0;                      // reserved
            }
            
            return blob;
        }

        function isDSTActive(date) {
            const month = date.getMonth() + 1;  // 1-12
            const dayOfMonth = date.getDate();
            const year = date.getFullYear();
            
            const rules = generateDSTRules();
            const rule = rules.find(r => r.year === year);
            
            if (!rule) return false;
            
            // March: DST if day >= spring_day
            // April-October: DST active
            // November: DST if day < fall_day
            // Dec-Feb: not DST
            
            if (month > 3 && month < 11) return true;
            if (month === 3 && dayOfMonth >= rule.spring_day) return true;
            if (month === 11 && dayOfMonth < rule.fall_day) return true;
            
            return false;
        }

        // ============= Serial Communication =============
        function handleArduinoLine(line) {
            if (!line) return;

            console.log('Arduino response:', line);
            serialLog.innerText = line;

            if (line.startsWith('ERR:F')) {
                statusDiv.innerText = `Status: Format switch failed (${line})`;
                statusDiv.classList.remove('text-green-500');
                statusDiv.classList.add('text-red-500');
                return;
            }

            if (line.startsWith('OK:F')) {
                const applied = line.slice(4).trim();
                const formatLabel = applied === '1' ? '12-Hour' : '24-Hour';
                statusDiv.innerText = `Status: Format ACK from device: ${formatLabel}`;
                statusDiv.classList.remove('text-red-500');
                statusDiv.classList.add('text-green-500');
                return;
            }

            if (line.startsWith('OK:QF')) {
                const applied = line.slice(5).trim();
                const is12 = applied === '1';
                isUpdatingFromDevice = true;
                format12hToggle.checked = is12;
                formatDisplay.innerText = is12 ? '12-Hour' : '24-Hour';
                isUpdatingFromDevice = false;
                statusDiv.innerText = `Status: Device format is ${is12 ? '12-Hour' : '24-Hour'} (QF)`;
                statusDiv.classList.remove('text-red-500');
                statusDiv.classList.add('text-green-500');
                return;
            }

            if (line.startsWith('DBG:F')) {
                statusDiv.innerText = `Status: ${line}`;
                statusDiv.classList.remove('text-red-500');
                statusDiv.classList.add('text-green-500');
            }
        }

        async function readLoop() {
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    const text = new TextDecoder().decode(value);
                    serialRxBuffer += text;

                    let newlineIndex;
                    while ((newlineIndex = serialRxBuffer.search(/[\r\n]/)) !== -1) {
                        const line = serialRxBuffer.slice(0, newlineIndex).trim();
                        serialRxBuffer = serialRxBuffer.slice(newlineIndex + 1);
                        handleArduinoLine(line);
                    }
                }
            } catch (err) {
                console.error('Read error:', err);
            }
        }

        async function sendCommand(cmd) {
            try {
                console.log('Sending:', cmd.trim());
                await writer.write(new TextEncoder().encode(cmd));
            } catch (err) {
                console.error('Send error:', err);
                throw err;
            }
        }

        // ============= Event Listeners =============
        connectBtn.addEventListener('click', async () => {
            try {
                if (isConnected) {
                    await cleanupSerialConnection();
                }

                const existingPorts = await navigator.serial.getPorts();
                if (existingPorts.length > 0) {
                    port = existingPorts[0];
                } else {
                    port = await navigator.serial.requestPort();
                }

                await port.open({ baudRate: 9600 });
                writer = port.writable.getWriter();
                reader = port.readable.getReader();
                isConnected = true;
                
                readLoop();
                
                statusDiv.innerText = "Status: Connected ✓";
                statusDiv.classList.add('text-green-500');
                statusDiv.classList.remove('text-neutral-400');
                controls.classList.remove('opacity-50', 'pointer-events-none');
                connectBtn.innerText = "Reconnect";
                connectBtn.disabled = false;
                disconnectBtn.classList.remove('hidden');
                
                // Update timezone display
                updateTimezoneDisplay();
                await sendCommand('QF\n');

            } catch (err) {
                statusDiv.innerText = "Error: " + err.message;
                statusDiv.classList.add('text-red-500');
            }
        });

        disconnectBtn.addEventListener('click', async () => {
            await cleanupSerialConnection();
            statusDiv.innerText = "Status: Disconnected";
            statusDiv.classList.remove('text-green-500');
            statusDiv.classList.add('text-neutral-400');
        });

        if (navigator.serial) {
            navigator.serial.addEventListener('disconnect', async () => {
                serialLog.innerText = 'Device disconnected';
                statusDiv.innerText = 'Status: Device disconnected. Click Connect.';
                statusDiv.classList.remove('text-green-500');
                statusDiv.classList.add('text-red-500');
                disconnectBtn.classList.add('hidden');
                await cleanupSerialConnection();
            });
        }

        format12hToggle.addEventListener('change', (e) => {
            if (isUpdatingFromDevice) {
                return;
            }
            const formatLabel = e.target.checked ? '12-Hour' : '24-Hour';
            formatDisplay.innerText = formatLabel;
            localStorage.setItem('format12h', e.target.checked ? '1' : '0');
        });

        timezoneSelect.addEventListener('change', (e) => {
            const option = e.target.options[e.target.selectedIndex];
            tzDisplay.innerText = option.text;
            localStorage.setItem('timezone', e.target.value);
        });

        brightnessSlider.addEventListener('input', (e) => {
            brightnessValue.innerText = e.target.value;
        });

        syncSettingsBtn.addEventListener('click', async () => {
            try {
                syncSettingsBtn.disabled = true;
                statusDiv.innerText = "Status: Syncing settings...";
                statusDiv.classList.remove('text-red-500');
                statusDiv.classList.add('text-green-500');

                const format = format12hToggle.checked ? 1 : 0;
                const brightness = parseInt(brightnessSlider.value);
                const timezone = parseInt(timezoneSelect.value);
                const now = new Date();
                const h = now.getHours();
                const m = now.getMinutes();
                const s = now.getSeconds();
                const month = now.getMonth() + 1;
                const day = now.getDate();
                const year = now.getFullYear();

                // Send all settings in sequence
                await sendCommand(`D${month},${day},${year}\n`);
                await new Promise(r => setTimeout(r, 50));

                await sendCommand(`T${h},${m},${s}\n`);
                await new Promise(r => setTimeout(r, 50));

                await sendCommand(`F${format}\n`);
                await new Promise(r => setTimeout(r, 50));

                await sendCommand(`Z${timezone}\n`);
                await new Promise(r => setTimeout(r, 50));

                await sendCommand(`B${brightness}\n`);
                await new Promise(r => setTimeout(r, 50));

                await sendCommand('QF\n');

                statusDiv.innerText = `Status: Settings synced! ${month}/${day}/${year} ${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
                statusDiv.classList.remove('text-red-500');
                statusDiv.classList.add('text-green-500');

            } catch (err) {
                console.error('Sync error:', err);
                statusDiv.innerText = "Status: Sync failed - " + err.message;
                statusDiv.classList.remove('text-green-500');
                statusDiv.classList.add('text-red-500');
            } finally {
                syncSettingsBtn.disabled = false;
            }
        });

        // ============= Initialization =============
        function updateTimezoneDisplay() {
            const tz = localStorage.getItem('timezone') || '0';
            timezoneSelect.value = tz;
            const option = timezoneSelect.options[timezoneSelect.selectedIndex];
            tzDisplay.innerText = option.text;
        }

        function restoreSavedPreferences() {
            const savedFormat = localStorage.getItem('format12h');
            if (savedFormat === '1') {
                format12hToggle.checked = true;
                formatDisplay.innerText = '12-Hour';
            } else {
                format12hToggle.checked = false;
                formatDisplay.innerText = '24-Hour';
            }
            
            updateTimezoneDisplay();
            
            // Update DST display
            const now = new Date();
            dstDisplay.innerText = isDSTActive(now) ? 'Active' : 'Standard';
        }

        // Load saved preferences on page load
        restoreSavedPreferences();
    </script>
</body>
</html>
